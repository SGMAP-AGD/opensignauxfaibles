---
title: "logistic_model_0_12.Rmd"
author: "Pierre Camilleri"
date: "28 mars 2018"
output: html_document
---

```{r}
library("opensignauxfaibles")
library("dplyr")
library("tidyverse")
library("mice")
library("R.utils")
library("nnet")
library("caret")
library("forcats")
library("lazyeval")
sourceDirectory("../tools",recursive = TRUE, modifiedOnly = FALSE,verbose = FALSE)
source('./data_pipes/data_prep_RJLJ_12m_imbalance_Paul_Antoine.R')
```

```{r}
formulas_0_12 <- list(
  "effectif" = outcome ~ cut_effectif,
  "cotisation_effectif" = outcome ~ cut_effectif + cut_growthrate + lag_effectif_missing +
  apart_last12_months + apart_consommee + apart_share_heuresconsommees +
  log_cotisationdue_effectif,
  "dettecumulee" = outcome ~ cut_effectif + cut_growthrate + lag_effectif_missing +
  apart_last12_months + apart_consommee + apart_share_heuresconsommees +
  log_cotisationdue_effectif +
  log_ratio_dettecumulee_cotisation + indicatrice_dettecumulee,
  "croissancedettecumulee" = outcome ~ cut_effectif + cut_growthrate + lag_effectif_missing +
  apart_last12_months + apart_consommee + apart_share_heuresconsommees +
  log_cotisationdue_effectif +
  log_ratio_dettecumulee_cotisation + indicatrice_dettecumulee +
  indicatrice_croissance_dettecumulee,
  "nb_debits" = outcome ~ cut_effectif + cut_growthrate + lag_effectif_missing +
  apart_last12_months + apart_consommee + apart_share_heuresconsommees +
  log_cotisationdue_effectif +
  log_ratio_dettecumulee_cotisation + indicatrice_dettecumulee +
  indicatrice_croissance_dettecumulee +
  nb_debits,
  "delais" = outcome ~ cut_effectif + cut_growthrate + lag_effectif_missing +
  apart_last12_months + apart_consommee + apart_share_heuresconsommees +
  log_cotisationdue_effectif +
  log_ratio_dettecumulee_cotisation + indicatrice_dettecumulee +
  indicatrice_croissance_dettecumulee +
  nb_debits +
  delai + delai_sup_6mois,
  "codenaf" = outcome ~ cut_effectif + cut_growthrate + lag_effectif_missing +
  apart_last12_months + apart_consommee + apart_share_heuresconsommees +
  log_cotisationdue_effectif +
  log_ratio_dettecumulee_cotisation + indicatrice_dettecumulee +
  indicatrice_croissance_dettecumulee +
  nb_debits +
  delai + delai_sup_6mois +
  libelle_naf_niveau1,
    "delais_bdf" = outcome ~ cut_effectif + cut_growthrate + lag_effectif_missing +
  apart_last12_months + apart_consommee + apart_share_heuresconsommees +
  log_cotisationdue_effectif +
  log_ratio_dettecumulee_cotisation + indicatrice_dettecumulee +
  indicatrice_croissance_dettecumulee +
  nb_debits +
  delai + delai_sup_6mois + neglog(taux_marge) + log(financier_ct + 0.01) + financier + delai_fournisseur,
    "delais_bdf2" = outcome ~ cut_effectif + cut_growthrate + lag_effectif_missing +
  apart_last12_months + apart_consommee + apart_share_heuresconsommees +
  log_cotisationdue_effectif +
  log_ratio_dettecumulee_cotisation + indicatrice_dettecumulee +
  indicatrice_croissance_dettecumulee +
  nb_debits +
  delai + delai_sup_6mois + taux_marge + financier_ct
)
```


```{r}


 
logisticModel <- function(myData,cv_folds,myFormula){
  ctrl <-
  trainControl(
  method = "cv",
  classProbs = TRUE,
  summaryFunction = prSummary,
  savePredictions = "final",
  index = cv_folds
  ) 
  llfit <- train(myFormula, 
                  data = myData, 
                  method = 'glm',
                  family = binomial,
                  metric = 'F',
                  trControl = ctrl,
                  maxit = 2000,
                 na.action = "na.omit")
  return(llfit)
}

fScore <- function(myData,idx_train,myFormula){
  logfit <- logisticModel(myData,idx_train,myFormula)
  prediction <-  predict(logfit,newdata = myData %>% select(-siret) %>% filter(!for_training))
  y <-  myData %>% filter(!for_training) 
  y <-  y$outcome

  precision <- posPredValue(prediction, y, positive = "default")
  recall <- sensitivity(prediction, y, positive = "default")
  
  F1 <- (2 * precision * recall) / (precision + recall)
  return(F1)
}

```

```{r}
# Explore formulae
plyr::ldply(
  .data = formulas_0_12,
  .fun = function(x) { fScore(sample_train,cv_fold,x) }
  )  
```

```{r}

# IMBALANCE

ctrl <-
  trainControl(
  method = "cv",
  classProbs = TRUE,
  summaryFunction = prSummary,
  savePredictions = "final",
  index = cv_folds
  ) 

formula <- formulas_0_12$dettecumulee
logmodel1_raw <- train(formula, 
                  data = sample_train, 
                  method = 'glm',
                  family = binomial,
                  metric = 'AUC',
                  trControl = ctrl,
                  maxit = 2000,
                 na.action = "na.omit")

formula2 <- formulas_0_12$delais_bdf2
logmodel2_raw <- train(formula2, 
                  data = sample_train, 
                  method = 'glm',
                  family = binomial,
                  metric = 'AUC',
                  trControl = ctrl,
                  maxit = 2000,
                 na.action = "na.omit")

formula3 <- formulas_0_12$delais_bdf3
logmodel3_raw <- train(formula3, 
                  data = sample_train, 
                  method = 'glm',
                  family = binomial,
                  metric = 'AUC',
                  trControl = ctrl,
                  maxit = 2000,
                 na.action = "na.omit")




```

```{r}
# WEIGHTS 

myWeights <- ifelse(sample_train$outcome == "default",
                  (1 / table(sample_train$outcome)[1]) * 0.5,
                  (1 / table(sample_train$outcome)[2]) * 0.5)

ctrl$weights <- myWeights


formula <- formulas_0_12$dettecumulee
logmodel1_wei <- train(formula, 
                  data = sample_train, 
                  method = 'glm',
                  family = binomial,
                  metric = 'AUC',
                  trControl = ctrl,
                  maxit = 2000,
                 na.action = "na.omit")

formula2 <- formulas_0_12$delais_bdf2
logmodel2_wei <- train(formula2, 
                  data = sample_train, 
                  method = 'glm',
                  family = binomial,
                  metric = 'AUC',
                  trControl = ctrl,
                  maxit = 2000,
                 na.action = "na.omit")
ctrl$weights <- NA
```

```{r}
# downsampling
ctrl$sampling = "down"

formula <- formulas_0_12$dettecumulee
logmodel1_down <- train(formula, 
                  data = sample_train, 
                  method = 'glm',
                  family = binomial,
                  metric = 'AUC',
                  trControl = ctrl,
                  maxit = 2000,
                 na.action = "na.omit")

formula2 <- formulas_0_12$delais_bdf2
logmodel2_down <- train(formula2, 
                  data = sample_train, 
                  method = 'glm',
                  family = binomial,
                  metric = 'AUC',
                  trControl = ctrl,
                  maxit = 2000,
                 na.action = "na.omit")

```

```{r}
# OVERSAMPLING
ctrl$sampling = "up"

formula <- formulas_0_12$dettecumulee
logmodel1_up <- train(formula, 
                  data = sample_train, 
                  method = 'glm',
                  family = binomial,
                  metric = 'AUC',
                  trControl = ctrl,
                  maxit = 2000,
                 na.action = "na.omit")

formula2 <- formulas_0_12$delais_bdf2
logmodel2_up <- train(formula2, 
                  data = sample_train, 
                  method = 'glm',
                  family = binomial,
                  metric = 'AUC',
                  trControl = ctrl,
                  maxit = 2000,
                 na.action = "na.omit")
```

```{r}
# SMOTE
ctrl$sampling = "smote"

formula <- formulas_0_12$dettecumulee
logmodel1_smote <- train(formula, 
                  data = sample_train, 
                  method = 'glm',
                  family = binomial,
                  metric = 'AUC',
                  trControl = ctrl,
                  maxit = 2000,
                 na.action = "na.omit")

formula2 <- formulas_0_12$delais_bdf2
logmodel2_smote <- train(formula2, 
                  data = sample_train, 
                  method = 'glm',
                  family = binomial,
                  metric = 'AUC',
                  trControl = ctrl,
                  maxit = 2000,
                 na.action = "na.omit")
```
```{r}

# SMOTE
ctrl$sampling = "rose"

formula <- formulas_0_12$dettecumulee
logmodel1_rose <- train(formula, 
                  data = sample_train, 
                  method = 'glm',
                  family = binomial,
                  metric = 'AUC',
                  trControl = ctrl,
                  maxit = 2000,
                 na.action = "na.omit")

formula2 <- formulas_0_12$delais_bdf2
logmodel2_rose <- train(formula2, 
                  data = sample_train, 
                  method = 'glm',
                  family = binomial,
                  metric = 'AUC',
                  trControl = ctrl,
                  maxit = 2000,
                 na.action = "na.omit")
```
```

```{r}

# nn_cross <- nn_train_cross %>% filter(for_training == FALSE)
# cross_prediction <- predict(logmodel,newdata = nn_train_cross %>% select(-siret) %>% filter(for_training == FALSE), type = "prob")
# pred_obs <-
#   data.frame(siret = nn_cross$siret, months = nn_cross$months, predit = cross_prediction[, "default"],
#   observe = 2 - as.numeric(nn_cross$outcome)) %>%
#   mutate(juste = abs(predit - observe) <= 0.5)
# 
# ggplot(pred_obs %>% filter(!is.na(months)), aes(x = months,fill = juste)) +
#   geom_bar(position = 'fill')

```

```{r}
# Redefine glm for threshold choice
# library(caret)
# 
# glm_code <- getModelInfo("glm", regex = FALSE)[[1]]
# glm_code$type <- c("Classification")
# glm_code$paraters <- data.frame(parameter = c("threshold"),
#                                 class = c("numeric"),
#                                 label = c("Probability threshold"))
# 
# glm_code$grid <- function(x, y, len = NULL, search = "grid") {
#   if (search == "grid") {
#   grid <- expand.grid(threshold = seq(.01, .99, length = len))
#   } else {
#   grid <- expand.grid(threshold = runif(n = len, 0, 1))
#   }
#   grid
# }
# 
# glm_code$loop <-  function(grid) {
#   library(plyr)
#   loop <- dataframe(threshold = 0.5)
#   submodels <- vector(mode = "list", length = nrow(loop))
#   
#   submodels[[1]] <- grid
#   list(loop = loop, submodels = submodels)
# }
# 
# 
# glm_code$predict <- function(modelFit, newdata, submodels = NULL) {
#   if (!is.data.frame(newdata))
#   newdata <- as.data.frame(newdata)
#   
#   if (modelFit$problemType == "Classification") {
#   probs <-  predict(modelFit, newdata, type = "response")
#   
#   out <- ifelse(probs < .5,
#   modelFit$obsLevel[1],
#   modelFit$obsLevel[2])
#   
#   if (!is.null(submodels)) {
#     tmp2 <- out
#     out <- vector(mode = "list", length = length(submodels$threshold))
#     out[[1]] <- tmp2
#     for (i in seq(along = submodels$threshold)) {
#     out[[i + 1]] <- ifelse(probs >= submodels$threshold[[i]],
#     modelFit$obsLevel[1],
#     modelFit$obsLevel[2])
#     }
#   } 
#   } else {
#   out <- predict(modelFit, newdata, type = "response")
#   }
#   out
# }
# 
# glm_code$prob <- function(modelFit, newdata, submodels = NULL) {
#   if (!is.data.frame(newdata))
#   newdata <- as.data.frame(newdata)
#   out <-
#   predict(modelFit, newdata, type = "response")
#   out <- cbind(1 - out, out)
#   ## glm models the second factor level, we treat the first as the
#   ## event of interest. See Details in ?glm
#   dimnames(out)[[2]] <-  modelFit$obsLevels
#   out
#   
#   if (!is.null(submodels)) {
#   probs <- out
#   out <-
#   vector(mode = "list",
#   length = length(submodels$threshold) + 1)
#   out <- lapply(out, function(x)
#   probs)
#   }
#   out
# }
# 
# fourStats <- function(data, lev = levels(data$obs), model = NULL) {
#   ## This code will get use the area under the ROC curve and the
#   ## sensitivity and specificity values using the current candidate
#   ## value of the probability threshold.
#   out <- c(prSummary(data, lev = levels(data$obs), model = NULL))
#   
#   ## The best possible model has sensitivity of 1 and specificity of 1. 
#   ## How far are we from that value?
#   c(out, Dist = out["F"])
# }
# ```
# 
# ```{r}
# 
# logmodel <- logisticModel(nn_train_cross,idx_train,formulas_0_12$dettecumulee)
# 
#   ctrl <-
#   trainControl(
#   method = "cv",
#   classProbs = TRUE,
#   summaryFunction = fourStats,
#   index = idx_train
#   ) 
#   
#   
# logmodel <- train(formulas_0_12$dettecumulee, 
#                   data = nn_train_cross, 
#                   method = glm_code,
#                   family = binomial,
#                   metric = 'myF',
#                  maximize = FALSE,
#                  tuneLength = 10,
#                   trControl = ctrl,
#                  na.action = "na.omit")

  


```


---
title: "logistic_algo1a"
author: "Pierre Camilleri"
date: "15 mai 2018"
output: html_document
---

## Imports
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Libraries
library(tidyverse)
library(tricky)
library(lubridate)
library(assertthat)
library(mongolite)
library(mice)
library(caret)
library(broom)
library(randomForest)
library(MLmetrics)
library(tibbletime)
library(PRROC)
library(broom)

# Sources
source("../tools/interface/connect_to_database.R")
source("../tools/data_prep/impute_missing_data_BdF.R")
source("../tools/objective/objective_RJ_LJ_PS.R")
source("../tools/split/split_snapshot_each_month.R")
source("../tools/utilities/elapsed_months.R")
source("../tools/post_analysis/export_top.R")

```

## Definition periode actuelle
```{r}
actual_period <- as.Date("2018-04-01")
```


## Recuperation des données dans MongoDB
```{r}
table_wholesample <- connect_to_database('algo1')
```

## Definition de l'objectif
```{r}
table_wholesample <- objective_RJ_LJ_PS(table_wholesample)

# Peut-etre a integrer a objective_RJ_... 
table_wholesample <- table_wholesample %>%
  mutate(outcome = fct_recode(
    as.factor(outcome),
    default = "TRUE",
    non_default = "FALSE"
  ) %>%
    fct_relevel(c("default","non_default")))

```

## Selection des features 
```{r}
table_wholesample_sel <- table_wholesample %>%
  select(siret,periode,outcome,outcome_any,date_defaillance, cut_effectif,cut_growthrate, lag_effectif_missing,
         apart_last12_months, apart_consommee, apart_share_heuresconsommees,
         log_cotisationdue_effectif,
         log_ratio_dettecumulee_cotisation_12m, indicatrice_dettecumulee_12m,
         #indicatrice_croissance_dettecumulee,
         #nb_debits,
         #delai, delai_sup_6mois,
         taux_marge, financier_court_terme, frais_financier, delai_fournisseur, poids_frng, dette_fiscale)
```
## Imputation des données manquantes

Uniquement si les données Banque de France ont été importées

```{r}
seed <- 1234
mids <-  impute_missing_data_BdF(table_wholesample_sel,seed)
tw_complete <- mice::complete(mids,1) %>% as_tbl_time(periode)
```

sinon 
```{r}
tw_complete <- table_wholesample_sel
```


## Split train test 

Avec suréchantillonnage. Les suréchantillons seront supprimés à la main dans les échantillons d'entraînement pour s'assurer une évaluation sur le même échantillon de validation croisé. 

```{r}
seed <- 10011
set.seed(seed)

samples <-
  split_snapshot_each_month(
    tw_complete,
    date_inf = as.Date("2015-01-01"),
    date_sup = as.Date("2016-12-01"),
    frac_train = 0.6,
    frac_cross = 0.2,
    frac_eyeball = 0.05
  )

sample_train <- samples$train %>% 
  left_join(tw_complete, by = c('siret','periode'))
  
cv_folds <- samples$cv_fold

sample_eyeball <- table_wholesample_sel %>%
  semi_join(samples$eyeball, by = c('siret','periode'))

sample_test <- tw_complete %>%
      semi_join(samples$test, by = c('siret','periode'))
```

## Model

Sans suréchantillonnage, cv à la mano comme un cochon 
```{r}
formula <-  outcome ~ cut_effectif + cut_growthrate + lag_effectif_missing +
  apart_last12_months + apart_consommee + apart_share_heuresconsommees +
  log_cotisationdue_effectif +
  log_ratio_dettecumulee_cotisation_12m + indicatrice_dettecumulee_12m

AUCPR <- numeric(length = 5)
F1 <- numeric(length = 5)

for (i in 1:5) {
    aux_train <- sample_train %>% 
      slice(cv_folds[[i]]) 
    # Suppression du suréchantillonnage dans l'échantillon d'entraînement 
    aux_train <- aux_train %>% 
      filter(periode == max(periode)) %>% 
      as.data.frame()
    
    aux_glm <- glm(formula, family = "binomial", data = aux_train %>% mutate(outcome =fct_relevel(outcome,c("non_default","default"))))
    
    aux_cv <- sample_train %>% 
      slice(-cv_folds[[i]]) %>% 
      broom::augment(aux_glm,newdata = .,type.predict = 'response') %>% 
      rename(prediction = .fitted)
    
    PR <-  pr.curve(scores.class0 = aux_cv$prediction,weights.class0 =  as.numeric(aux_cv$outcome == 'default'),curve = TRUE)
    AUCPR[i] <-  PR$auc.integral
    F1[i] <- max(2*PR$curve[,1] * PR$curve[,2] / (PR$curve[,1] + PR$curve[,2]),na.rm = TRUE)
}

final_glm <- glm(
  formula,
  family = 'binomial',
  data = aux_train %>% filter(periode == max(periode)) %>% as_data_frame()
  )

algo1a_AUC <- mean(AUCPR)
algo1a_F <- mean(F1)
```

Avec suréchantillonnage
```{r}
formula <-  outcome ~ cut_effectif + cut_growthrate + lag_effectif_missing +
  apart_last12_months + apart_consommee + apart_share_heuresconsommees +
  log_cotisationdue_effectif +
  log_ratio_dettecumulee_cotisation_12m + indicatrice_dettecumulee_12m

ctrl <-
  trainControl(
    method = "cv",
    classProbs = TRUE,
    summaryFunction = prSummary,
    savePredictions = "all",
    index = cv_folds
  )

glm1b_res <- train(formula,
                      data = sample_train,
                      method = 'glm',
                      metric = 'AUC',
                      trControl = ctrl,
                      tuneLength = 10,
                      na.action = "na.omit")

algo1b_AUC <- glm1b_res$results$AUC
```


Avec donnees Banque de France
```{r}
formula <-  outcome ~ cut_effectif + cut_growthrate + lag_effectif_missing +
  apart_last12_months + apart_consommee + apart_share_heuresconsommees +
  log_cotisationdue_effectif +
  log_ratio_dettecumulee_cotisation_12m + indicatrice_dettecumulee_12m + 
  taux_marge + financier_ct + financier + delai_fournisseur + poids_frng + dette_fiscale

ctrl <-
  trainControl(
    method = "cv",
    classProbs = TRUE,
    summaryFunction = prSummary,
    savePredictions = "all",
    index = cv_folds
  )

glm1c_res <- train(formula,
                      data = sample_train,
                      method = 'glm',
                      metric = 'AUC',
                      trControl = ctrl,
                      tuneLength = 10,
                      na.action = "na.omit")

algo1c_AUC <- glm1c_res$results$AUC
algo1c_F1 <- glm1c_res$results$F
```

Avec foret aleatoire

```{r}
set.seed(1900)
formula <-  outcome ~ cut_effectif + cut_growthrate + lag_effectif_missing +
  apart_last12_months + apart_consommee + apart_share_heuresconsommees +
  log_cotisationdue_effectif +
  log_ratio_dettecumulee_cotisation_12m + indicatrice_dettecumulee_12m + 
  taux_marge + financier_court_terme + frais_financier + delai_fournisseur + poids_frng + dette_fiscale

ctrl <- 
  trainControl( 
    method = "cv", 
    classProbs = TRUE, 
    summaryFunction = prSummary, 
    savePredictions = "all", 
    index = cv_folds 
  ) 
 
attr(sample_train$outcome,'contrasts') <- NULL
randomForest <- train(formula, 
                 data =  sample_train %>% 
                   mutate(outcome = fct_relevel(outcome,c('default','non_default'))), 
                 method = 'ranger', 
                 metric = 'AUC', 
                 trControl = ctrl, 
                 tuneLength = 10, 
                 na.action = "na.omit") 

algo2a_AUC <- max(randomForest$results$AUC)

```

VERIF Foret aleatoire
```{r}
AUCPR <- numeric(length = 5)
F1 <- numeric(length = 5)
for (i in 1:5) {
    aux_train <- sample_train %>%
      slice(cv_folds[[i]])

    aux_train <- aux_train %>%
      as.data.frame()
    
    ctrl <- 
  trainControl( 
    method = "none", 
    classProbs = TRUE, 
    summaryFunction = prSummary, 
    savePredictions = "all"
  ) 
 
aux_randomForest <- train(formula, 
                 data = aux_train, 
                 method = 'rf', 
                 metric = 'AUC', 
                 trControl = ctrl, 
                 tuneLength = 1, 
                 na.action = "na.omit") 
    
    aux_cv <- sample_train %>% 
      slice(-cv_folds[[i]]) 
    
    preds <- predict(aux_randomForest,newdata = aux_cv,type='prob')
      
    aux_cv <- aux_cv %>% 
      mutate(prediction = preds$default)
    
    PR <-  pr.curve(scores.class0 = aux_cv$prediction,weights.class0 =  as.numeric(aux_cv$outcome == 'default'),curve = TRUE)
    AUCPR[i] <-  PR$auc.integral
    F1[i] <- max(2*PR$curve[,1] * PR$curve[,2] / (PR$curve[,1] + PR$curve[,2]),na.rm = TRUE)
}

algo2a_AUC <- mean(AUCPR)
algo2a_F <- mean(F1)
```


Avec moyenne glissante sur trois périodes
```{r}
# AUCPR <- numeric(length = 5)
# for (i in 1:5) {
#     # aux_train <- sample_train %>% 
#     #   slice(cv_folds[[i]]) 
#     # 
#     # aux_train <- aux_train %>% 
#     #   as.data.frame()
#     
#     aux_cv <- randomForest$pred[[randomForest$pred 
#       # sample_train %>% 
#       # slice(-cv_folds[[i]]) %>% 
#       # broom::augment(aux_glm,newdata = .,type.predict = 'response') %>% 
#       # rename(prediction = .fitted)
#     
#     PR <-  pr.curve(scores.class0 = aux_cv$prediction,weights.class0 =  as.numeric(aux_cv$outcome == 'default'),curve = TRUE)
#     AUCPR[i] <-  PR$auc.integral
#     F1[i] <- max(2*PR$curve[,1] * PR$curve[,2] / (PR$curve[,1] + PR$curve[,2]),na.rm = TRUE)
# }
```


## TEST
```{r}

```


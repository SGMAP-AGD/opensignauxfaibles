---
title: "Untitled"
author: "Pierre Camilleri"
date: "25 juillet 2018"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
# Libraries
library(tidyverse)
library(tricky)
library(lubridate)
library(assertthat)
library(mongolite)
library(mice)
library(caret)
library(broom)
library(keras)
library(randomForest)
library(MLmetrics)
library(tibbletime)
library(PRROC)
library(broom)
library(rprojroot)
library(groupdata2)
library(h2o)
library(R.utils)

# Sources
sourceDirectory(find_rstudio_root_file('tools'), modifiedOnly = FALSE)
```


```{r}
actual_period <- as.Date("2018-08-01")
```

```{r}
raw_data <- connect_to_database('Features', '1809', algo = 'algo2', min_effectif = 20)
```

```{r}
# FIX ME
# Cotisations avec un mois de décalage.
cat('FIX ME: offset with cotisation')

raw_data[ raw_data$periode == actual_period, "cotisation"] <- NA
raw_data <- raw_data %>% 
  arrange(siret,periode) %>% 
  fill(cotisation)
```

```{r}
raw_data <- raw_data %>%
  objective_default_or_failure(n_months = 3, threshold = 1, lookback = 18) %>%
  set_objective('default')
```

Train test split
```{r}
seed <- 1001
set.seed(seed)

samples <-
  split_snapshot_rdm_month(
    raw_data,
    date_inf = as.Date("2015-01-01"),
    date_sup = as.Date("2016-12-01"),
    frac_train = 0.6,
    frac_val = 0.2
  )


sample_train <- samples$train %>%
  left_join(raw_data, by = c('siret','periode'))

sample_validation <- raw_data %>%
  semi_join(samples$validation, by = c('siret','periode'))

sample_test <- raw_data %>%
  semi_join(samples$test, by = c('siret','periode'))

rm(samples)
assert_split_consistency(sample_train, sample_validation,sample_test)
```

```{r}


out <- feature_engineering_std(sample_train, sample_validation)
sample_train <- out[[1]]
sample_validation <- out[[2]]

# reference for feature engineering
ref_f_e <- feature_engineering_create(sample_train)

out <- feature_engineering_apply(ref_f_e, sample_train, sample_validation)
sample_train <- out[[1]]
sample_validation <- out[[2]]
```

```{r}
# If not enough memory, run systemctl restart mongod

gc()
h2o.init(ip = "localhost", port = 4444)
train.hex <- as.h2o(sample_train)
validation.hex <- as.h2o(sample_validation)
```


Définition classe positive
```{r}
train.hex['outcome'] <- h2o.relevel(x = train.hex['outcome'], y = "non_default")
validation.hex['outcome'] <- h2o.relevel(x = validation.hex['outcome'], y = "non_default")
```

Target encoding APE
```{r}
te_map <- h2o.target_encode_create(
  train.hex, 
  x = list(c('code_naf_niveau1'), c('code_ape_niveau2'), c('code_ape_niveau3'), c('code_ape_niveau4'), c('code_ape')), 
  train.hex, 
  x = list(c('code_naf_niveau1'),c('code_ape_niveau2'), c('code_ape_niveau3'), c('code_ape_niveau4'), c('code_ape')), 
  y = 'outcome',
  target_encode_map = te_map,
  holdout_type = 'KFold',
  fold_column = 'fold_column',
  blended_avg = TRUE,
  seed = 1234)

validation.hex <- h2o.target_encode_apply(
  validation.hex,
  x = list(c('code_naf_niveau1'), c('code_ape_niveau2'), c('code_ape_niveau3'), c('code_ape_niveau4'), c('code_ape')),
  y = 'outcome',
  target_encode_map = te_map, 
  holdout_type = 'None',
  blended_avg = FALSE,
  fold_column = 'fold_column',
  noise_level = 0)

```

```{r}
### Validation sur les signaux faibles uniquement

validation.hex <- validation.hex[(validation.hex[,'etat_proc_collective'] == 'in_bonis') && (as.numeric(validation.hex[,'default_urssaf']) == 0),]

```

#Only test
```{r}
out <- feature_engineering_std(sample_test)
sample_test <- out[[1]]

out <-feature_engineering_apply(ref_f_e, sample_test)

test.hex <- as.h2o(sample_test)

test.hex['outcome'] <- h2o.relevel(x = test.hex['outcome'], y = "non_default")

test.hex <- h2o.target_encode_apply(
  test.hex,
  x = list(c('code_naf_niveau1'), c('code_ape_niveau2'), c('code_ape_niveau3'), c('code_ape_niveau4'), c('code_ape')),
  y = 'outcome',
  target_encode_map = te_map, 
  holdout_type = 'None',
  blended_avg = FALSE, 
  fold_column = 'fold_column',
  noise_level = 0)

test.hex <- test.hex[(test.hex[,'etat_proc_collective'] == 'in_bonis') && (as.numeric(test.hex[,'default_urssaf']) == 0),]
```

```{r}

x_paul_antoine = c(
  "effectif",
  "effectif_diff_moy12",
  "apart_heures_consommees",
  "ratio_apart",
  "ratio_dette",
  "dette_any_12m",
  "montant_part_patronale_variation_12"
)

x_minimal = c(    
  "effectif",
  "effectif_diff_moy12",
  "apart_heures_consommees",
  "ratio_apart",
  "cotisation",                                
  "montant_part_ouvriere",                    
  "montant_part_patronale",
  "ratio_dette_moy12m",
  #"dette_any_12m",
  "ratio_dette",
  "poids_frng",                               
  "taux_marge",                                
  "delai_fournisseur",                         
  "dette_fiscale",                            
  "financier_court_terme",                     
  "frais_financier")

ratios_diane =c(
  "CA",
  "chiffre_affaires_net_lie_aux_exportations",
  "resultat_net_consolide",
  "ratio_CAF",
  "ratio_marge_operationnelle",
  "taux_rotation_stocks",
  "ratio_productivite",
  "ratio_export",
  "ratio_delai_client",
  "ratio_liquidite_reduite",
  "ratio_endettement",
  "ratio_rend_capitaux_propres",
  "ratio_rend_des_ress_durables",
  "ratio_RetD", 
  "taux_marge_neg",
  "taux_marge_extr_neg",
  "taux_marge_extr_pos")

new_variables = c(
  "etat_proc_collective_num",   
  "delai",
  "montant_echeancier",
  "ratio_dette_delai",
  "duree_delai",
  "age",
  "productif",
  "indice_monoactivite",
  "effectif_entreprise",
  "apart_entreprise",
  "nbr_etablissements_connus",
  "resultat_net_consolide",
  "nombre_etab_secondaire")#,
  #"code_naf_niveau1")

variations = c(grep('variation',names(sample_train), value = TRUE),
               grep('diff_moy12',names(sample_train), value = TRUE))

distrib = c(grep('distrib',names(sample_train), value = TRUE),
          'TargetEncode_code_naf_niveau1', 
          'TargetEncode_code_ape_niveau2',
          'TargetEncode_code_ape_niveau3')#,
          #'TargetEncode_code_ape_niveau4')#,
          #'TargetEncode_code_ape')

x_distrib = c(x_minimal,
              ratios_diane,
              new_variables,
              variations,
              distrib)

x_preface = c(
  x_distrib,
  "note_preface")

x_without_diane = c(
  x_minimal, 
  "delai",
  "montant_echeancier",
  "ratio_dette_delai",
  "duree_delai",
  "age",
  "productif",
  "indice_monoactivite",
  "effectif_entreprise",
  "apart_entreprise",
  "nbr_etablissements_connus",
  "resultat_net_consolide",
  "nombre_etab_secondaire",
  "code_naf_niveau1",
  "effectif_diff_moy12",
  "taux_marge_distrib_APE1",
  "taux_marge_distrib_APE2",
  "poids_frng_distrib_APE1",
  "poids_frng_distrib_APE2",
  "effectif_distrib_APE1",
  "effectif_distrib_APE2",
  "financier_court_terme_distrib_APE1",
  "financier_court_terme_distrib_APE2",
  "delai_fournisseur_distrib_APE1",
  "delai_fournisseur_distrib_APE2",
  "frais_financier_distrib_APE1",
  "frais_financier_distrib_APE2",
  "apart_heures_consommees_variation_1",
  "apart_heures_consommees_variation_2",
  "apart_heures_consommees_variation_3",
  "apart_heures_consommees_variation_6",
  "apart_heures_consommees_variation_12",
  "montant_part_patronale_variation_1",
  "montant_part_patronale_variation_2",
  "montant_part_patronale_variation_3",
  "montant_part_patronale_variation_6",
  "montant_part_patronale_variation_12",
  "montant_part_ouvriere_variation_1" ,
  "montant_part_ouvriere_variation_2" ,
  "montant_part_ouvriere_variation_3" ,
  "montant_part_ouvriere_variation_6" ,
  "montant_part_ouvriere_variation_12" )

x_without_urssaf = c(
  "effectif",
  "effectif_diff_moy12",
  "apart_heures_consommees",
  "ratio_apart",
  "cotisation",                        
  "ratio_dette_moy12m",
  "poids_frng",                               
  "taux_marge",                                
  "delai_fournisseur",                         
  "dette_fiscale",                            
  "financier_court_terme",                     
  "frais_financier",
  "delai",
  "montant_echeancier",
  "ratio_dette_delai",
  "duree_delai",
  "age",
  "productif",
  "indice_monoactivite",
  "effectif_entreprise",
  "apart_entreprise",
  "nbr_etablissements_connus",
  "resultat_net_consolide",
  "nombre_etab_secondaire",
  "code_naf_niveau1",
  "effectif_diff_moy12",
  "taux_marge_distrib_APE1",
  "taux_marge_distrib_APE2",
  "poids_frng_distrib_APE1",
  "poids_frng_distrib_APE2",
  "effectif_distrib_APE1",
  "effectif_distrib_APE2",
  "financier_court_terme_distrib_APE1",
  "financier_court_terme_distrib_APE2",
  "delai_fournisseur_distrib_APE1",
  "delai_fournisseur_distrib_APE2",
  "frais_financier_distrib_APE1",
  "frais_financier_distrib_APE2",
  "apart_heures_consommees_variation_1",
  "apart_heures_consommees_variation_2",
  "apart_heures_consommees_variation_3",
  "apart_heures_consommees_variation_6",
  "apart_heures_consommees_variation_12",
  ratios_diane)

x_distrib_less_debit <- x_distrib[-c(75,76,78,79)]

x_medium <- c("montant_part_patronale",                   
              "ratio_dette",                              
              "ratio_dette_moy12m",                       
              "etat_proc_collective_num",                 
              "TargetEncode_code_ape_niveau3",            
              "cotisation",                               
              "frais_financier_distrib_APE1",             
              "taux_marge_distrib_APE1",
              "taux_marge_distrib_APE2",
              "montant_part_patronale_variation_3",       
              "ratio_liquidite_reduite_distrib_APE1",
              #"ratio_liquidite_reduite_distrib_APE2",
              "dette_fiscale",                            
              "ratio_delai_client_distrib_APE1",          
              "montant_part_patronale_variation_1",       
              "montant_part_patronale_variation_2",       
              "ratio_rend_capitaux_propres",              
              "taux_marge",                               
              "poids_frng_distrib_APE1",
              "delai_fournisseur_distrib_APE2", 
              "delai_fournisseur_distrib_APE1",   
              "delai_fournisseur_distrib_APE2", 
              "taux_rotation_stocks_distrib_APE1",        
              "effectif",                                 
              "ratio_rentabilite_nette_distrib_APE1",     
              "ratio_export_distrib_APE1",                
              "TargetEncode_code_ape_niveau2",            
              "effectif_diff_moy12",                      
              "montant_part_ouvriere",                    
              "financier_court_terme_distrib_APE1",       
              #"effectif_entreprise",                      
              "age",                                      
              "ratio_liquidite_reduite",                  
              "ratio_productivite_distrib_APE1",          
              "frais_financier",                          
              "financier_court_terme",                    
              "ratio_delai_client",                       
              "TargetEncode_code_naf_niveau1",            
              "resultat_net_consolide",                   
              "taux_rotation_stocks",                     
              "nombre_etab_secondaire",                   
              "nbr_etablissements_connus",                
              "CA",                                       
              "chiffre_affaires_net_lie_aux_exportations",
              "ratio_dette_delai",                        
              "ratio_marge_operationnelle_distrib_APE1",  
              "poids_frng")  

y = "outcome"
```


## Logistic regression
```{r logistic ridge regression }

# glm_ridge <- h2o.glm(
#   model_id = 'GLM_ridge',
#   x= x_distrib,
#   y =y,
#   training_frame = train.hex,
#   validation_frame = validation.hex,
#   family = "binomial",
#   alpha = 0, #ridge
#   lambda_search = TRUE,
#   standardize = TRUE,
#   missing_values_handling = "MeanImputation",
#   seed = 123,
#   score_each_iteration = TRUE
# )
```

```{r logistic lasso regression }

# glm_lasso <- h2o.glm(
#   model_id = 'GLM_lasso',
#   x= x_distrib, 
#   y =y,
#   training_frame = train.hex,
#   validation_frame = validation.hex,
#   family = "binomial",
#   alpha = 1, #LASSO
#   lambda_search = TRUE,
#   standardize = TRUE,
#   missing_values_handling = "MeanImputation",
#   seed = 123, 
#   score_each_iteration = TRUE 
# )
# 
# path <- h2o.getGLMFullRegularizationPath(glm_lasso)
# 
# toPlot <- cbind(lambdas = path$lambdas, 
#                 path$coefficients) %>% 
#   as.tibble() %>% 
#   gather(myVariable, myValue, - lambdas )
# 
# gg <-  ggplot(toPlot, aes(x = lambdas, y = myValue, color = myVariable)) + theme(legend.position = "none") + geom_line_interactive(aes(tooltip = myVariable))  
# ggiraph(code = print(gg), zoom_max = 10)
# 
# classement <- toPlot %>% 
#   filter(abs(myValue) > 0.0001) %>%
#   group_by(myVariable) %>% 
#   arrange(desc(lambdas)) %>% 
#   summarize_all(first) %>%  
#   arrange(desc(lambdas))

```
## Light gradient boosting
### Starting point
```{r light gradient boosting}

xgb_start <- h2o.xgboost(
  model_id = 'LGB_model_start',
  x= x_medium, 
  y =y,
  training_frame = train.hex,
  validation_frame = validation.hex,
  tree_method = "hist",
  grow_policy = "lossguide",
  learn_rate = 0.1,
  max_depth = 4,
  ntrees = 60,
  seed = 123, 
  score_each_iteration = FALSE,
  stopping_rounds = 4,
  quiet_mode =  FALSE
)

cat(xgb_start@model$validation_metrics@metrics$pr_auc)

plotPR(xgb_start)
```


## Feature reduction ?
```{r lgb feature reduction}
classement_v <- classement[['myVariable']]

classement_v <- classement_v[-c(1,17,18,31,41,44,45)] %>%
  c("taux_marge_neg","dette_any_12m","code_naf_niveau1")


xgb_feature_reduction <- h2o.xgboost(
  model_id = 'LGB_model_Feature_reduction',
  x= classement_v, 
  y =y,
  training_frame = train.hex,
  validation_frame = validation.hex,
  tree_method = "hist",
  grow_policy = "lossguide",
  learn_rate = 0.05,
  max_depth = 4,
  ntrees = 120,
  seed = 123, 
  score_each_iteration = TRUE,
  stopping_rounds = 4,
  quiet_mode =  FALSE
)
``` 


```{r random forest}
# Random forest

new_rf_model <- h2o.randomForest(
  model_id = 'RF_model',
  x= x_distrib, 
  y =y,
  training_frame = train.hex,
  balance_classes = TRUE,
  ntrees = 200,
  seed = 123, 
  score_each_iteration = TRUE,
  stopping_rounds = 4,
  stopping_tolerance = 0.001,
  keep_cross_validation_predictions = TRUE
)
```




## Model ensembling

```{r}
xgb_ensemble <- h2o.xgboost(
  model_id = 'LGB_model_for_ensemble',
  x= x_distrib, 
  y =y,
  training_frame = train.hex,
  validation_frame = validation.hex,
  tree_method = "hist",
  grow_policy = "lossguide",
  fold_column = "fold_column",
  learn_rate = 0.1,
  max_depth = 4,
  ntrees = 60,
  seed = 123, 
  score_each_iteration = TRUE,
  stopping_rounds = 4,
  quiet_mode =  FALSE,
  keep_cross_validation_predictions = TRUE, 
  keep_cross_validation_fold_assignment = TRUE
)

cat(xgb_ensemble@model$validation_metrics@metrics$pr_auc)
plotPR(xgb_ensemble)
```

```{r}
glm_ridge_ensemble <- h2o.glm(
  model_id = 'GLM_ridge_for_ensemble',
  x= x_distrib,
  y =y,
  training_frame = train.hex,
  validation_frame = validation.hex,
  fold_column = "fold_column",
  family = "binomial",
  alpha = 0, #ridge
  lambda_search = TRUE,
  standardize = TRUE,
  missing_values_handling = "MeanImputation",
  seed = 123,
  score_each_iteration = TRUE,
  keep_cross_validation_predictions = TRUE, 
  keep_cross_validation_fold_assignment = TRUE
)

cat(glm_ridge_ensemble@model$validation_metrics@metrics$pr_auc)
```

```{r}
glm_lasso_without_diane_ensemble <- h2o.glm(
  model_id = 'GLM_lasso_financial_for_ensemble',
  x= x_without_diane,
  y =y,
  training_frame = train.hex,
  validation_frame = validation.hex,
  fold_column = "fold_column",
  family = "binomial",
  alpha = 1, #lasso
  lambda_search = TRUE,
  standardize = TRUE,
  missing_values_handling = "MeanImputation",
  seed = 123,
  score_each_iteration = TRUE,
  keep_cross_validation_predictions = TRUE, 
  keep_cross_validation_fold_assignment = TRUE
)

cat(glm_ridge_ensemble@model$validation_metrics@metrics$pr_auc)
```

```{r}
glm_lasso_financial_ensemble <- h2o.glm(
  model_id = 'GLM_lasso_financial_for_ensemble',
  x= x_without_urssaf,
  y =y,
  training_frame = train.hex,
  validation_frame = validation.hex,
  fold_column = "fold_column",
  family = "binomial",
  alpha = 1, #lasso
  lambda_search = TRUE,
  standardize = TRUE,
  missing_values_handling = "MeanImputation",
  seed = 123,
  score_each_iteration = TRUE,
  keep_cross_validation_predictions = TRUE, 
  keep_cross_validation_fold_assignment = TRUE
)

cat(glm_ridge_ensemble@model$validation_metrics@metrics$pr_auc)
```

```{r}
xgb_ensemble_without_urssaf <- h2o.xgboost(
  model_id = 'LGB_model_for_ensemble',
  x= x_without_urssaf, 
  y =y,
  training_frame = train.hex,
  validation_frame = validation.hex,
  tree_method = "hist",
  grow_policy = "lossguide",
  fold_column = "fold_column",
  learn_rate = 0.1,
  max_depth = 4,
  ntrees = 60,
  seed = 123, 
  score_each_iteration = TRUE,
  stopping_rounds = 4,
  quiet_mode =  FALSE,
  keep_cross_validation_predictions = TRUE, 
  keep_cross_validation_fold_assignment = TRUE
)

cat(xgb_ensemble@model$validation_metrics@metrics$pr_auc)
plotPR(xgb_ensemble)
```

```{r}
ensemble <- h2o.stackedEnsemble(
  metalearner_algorithm = "glm",
  base_models = list(
    glm_ridge_ensemble
    ),
  x = x_distrib,
  y = y, 
  metalearner_fold_column = 'fold_column',
  training_frame = train.hex,
  validation_frame = validation.hex,
  seed = 123
)


plotPR(ensemble, F)
```


